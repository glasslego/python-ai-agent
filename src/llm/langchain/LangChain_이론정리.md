# LangChain 이론 정리

## 1. 기본 LLM (Large Language Model) 사용

### 핵심 개념
- **LLM**: 텍스트 이해 및 생성을 수행하는 언어 모델
- **Temperature**: 응답의 창의성/무작위성 조절 (0~1)
  - 0에 가까울수록: 일관적이고 예측 가능한 응답
  - 1에 가까울수록: 창의적이고 다양한 응답

### 주요 기능
1. **단순 호출**: `llm.invoke(질문)` 형태로 직접 질문/답변
2. **파라미터 조절**: 모델, temperature, max_tokens 등 설정
3. **스트리밍**: 실시간으로 응답을 청크 단위로 받기

### 실제 활용
- 단순한 Q&A 시스템
- 텍스트 생성 및 요약
- 번역 및 변환 작업

---

## 2. 프롬프트 템플릿 (Prompt Template)

### 핵심 개념
- **템플릿**: 변수를 포함한 재사용 가능한 프롬프트 구조
- **변수 치환**: `{변수명}` 형태로 동적 내용 삽입
- **프롬프트 엔지니어링**: 효과적인 프롬프트 설계 기법

### 템플릿 종류
1. **기본 템플릿**: 단순 문자열 치환
2. **대화 템플릿**: 시스템 메시지 + 사용자 메시지 구조
3. **Few-Shot 템플릿**: 예시를 포함한 학습 유도

### 활용 패턴
- **역할 부여**: "당신은 {역할}입니다"
- **스타일 지정**: "{스타일} 방식으로 답변하세요"
- **형식 정의**: 출력 형태를 명확히 지정

---

## 3. 체인 (Chain)

### 핵심 개념
- **체인**: 여러 작업을 연결한 파이프라인
- **LCEL (LangChain Expression Language)**: `|` 연산자를 통한 체인 연결
- **순차 처리**: 이전 단계의 출력이 다음 단계의 입력

### 체인 종류
1. **순차적 체인**: A → B → C 형태의 선형 처리
2. **병렬 체인**: 여러 작업을 동시에 수행
3. **조건부 체인**: 특정 조건에 따른 분기 처리

### 출력 파서 활용
- **StrOutputParser**: 문자열 출력
- **CommaSeparatedListOutputParser**: 쉼표로 구분된 리스트
- **JSONOutputParser**: JSON 형태 구조화된 출력

### 실제 활용 사례
- **창작 체인**: 주제 → 시놉시스 → 제목 생성
- **분석 체인**: 텍스트 → 감정분석 + 요약 + 키워드 추출
- **번역 체인**: 원문 → 번역 → 검토 → 최종 출력

---

## 4. 메모리 (Memory)

### 핵심 개념
- **대화 기억**: 이전 대화 내용을 저장하여 문맥 유지
- **세션 관리**: 사용자별/대화별 독립적 메모리 공간
- **메모리 최적화**: 저장 용량과 성능 간의 균형

### 메모리 종류
1. **버퍼 메모리**: 전체 대화 내용을 그대로 저장
   - 장점: 완전한 문맥 보존
   - 단점: 메모리 사용량 증가

2. **요약 메모리**: 대화를 요약해서 저장
   - 장점: 메모리 효율성
   - 단점: 세부 정보 손실 가능

3. **윈도우 메모리**: 최근 K개의 대화만 저장
   - 장점: 고정된 메모리 사용
   - 단점: 오래된 정보 손실

### 최신 구현 방식
- **RunnableWithMessageHistory**: 세션 기반 메모리 관리
- **MessagesPlaceholder**: 대화 히스토리 삽입점
- **세션 스토어**: 다중 사용자 대화 관리

---

## 5. RAG (Retrieval-Augmented Generation)

### 핵심 개념
- **검색 증강 생성**: 외부 지식을 검색하여 답변에 활용
- **두 단계 처리**: 관련 문서 검색 → 검색 결과 기반 답변 생성
- **지식 베이스**: 도메인 특화 정보를 구조화하여 저장

### RAG 파이프라인
1. **문서 준비**: 텍스트 분할, 메타데이터 추가
2. **검색 (Retrieval)**: 질문과 관련된 문서 찾기
3. **생성 (Generation)**: 검색된 문서 기반 답변 생성

### 고급 기법
1. **메타데이터 활용**: 출처, 날짜, 카테고리 등 추가 정보
2. **필터링**: 카테고리, 날짜 범위, 키워드 기반 선별
3. **재순위화 (Reranking)**: LLM을 활용한 관련성 재평가

### 검색 기법
- **TF-IDF**: 단어 빈도 기반 유사도 계산
- **코사인 유사도**: 벡터 공간에서의 각도 기반 유사도
- **의미적 검색**: 임베딩 기반 의미 유사도

---

## 전체 아키텍처 통합

### 일반적인 LangChain 애플리케이션 구조
```
입력 → 프롬프트 템플릿 → LLM → 출력 파서 → 후처리
       ↑                    ↑
     메모리           RAG 검색 결과
```

### 핵심 설계 원칙
1. **모듈화**: 각 구성요소를 독립적으로 설계
2. **재사용성**: 템플릿과 유틸리티 함수 활용
3. **확장성**: 새로운 기능 추가가 용이한 구조
4. **성능 최적화**: 캐싱, 비동기 처리, 배치 처리

### 실무 적용 시 고려사항
- **API 비용 관리**: 토큰 사용량 최적화
- **응답 시간**: 캐싱과 병렬 처리 활용
- **품질 관리**: 프롬프트 테스트 및 평가 체계
- **보안**: API 키 관리 및 민감 정보 처리

---

## 개발 환경 설정

### 필수 라이브러리
- `langchain`: 핵심 프레임워크
- `langchain-openai`: OpenAI API 연동
- `python-dotenv`: 환경변수 관리
- `numpy`, `scikit-learn`: 벡터 연산 (RAG용)

### 환경 변수
```
OPENAI_API_KEY=your-api-key-here
```

### 프로젝트 구조
```
src/llm/langchain/
├── llm_utils.py        # 공통 유틸리티
├── 1_basic_llm.py      # 기본 LLM 사용
├── 2_prompt_template.py # 프롬프트 템플릿
├── 3_chain.py          # 체인 연결
├── 4_memory.py         # 메모리 관리
└── 5_rag.py           # RAG 구현
```
